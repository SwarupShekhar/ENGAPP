// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User model
model User {
  id          String    @id @default(uuid())
  clerkId     String    @unique
  fname       String
  lname       String
  gender      String?
  hobbies     String[]
  nativeLang  String
  level       String
  overallLevel String?
  talkStyle        TalkStyle?
  levelUpdatedAt   DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  participants SessionParticipant[]
  tasks        LearningTask[]
  profile      Profile?
  assessments  AssessmentSession[]
  
  // Reviews given and received
  reviewsGiven    PartnerReview[] @relation("ReviewsGiven")
  reviewsReceived PartnerReview[] @relation("ReviewsReceived")
  
  // Blocking relations
  blockedUsers    BlockedUser[] @relation("BlockingUser")
  blockedBy       BlockedUser[] @relation("BlockedUser")

  // Friendship relations
  friendshipsRequested Friendship[] @relation("FriendshipRequester")
  friendshipsReceived  Friendship[] @relation("FriendshipAddressee")
  friendRequestsSent   FriendRequest[] @relation("FriendRequestSender")
  friendRequestsReceived FriendRequest[] @relation("FriendRequestReceiver")
  sentMessages         ChatMessage[] @relation("MessageSender")
  receivedMessages     ChatMessage[] @relation("MessageReceiver")

  // Chat system (conversation-based)
  chatParticipants     ConversationParticipant[]
  chatMessages         Message[]     @relation("ChatMessagesSent")

  // Gamification & Reliability
  reliability     UserReliability?
  points          UserPoints?
  matchmakingQueue MatchmakingQueue[]
  topicScores     UserTopicScore[]
  reelHistory     UserReelHistory[]

  @@index([clerkId])
}

model UserReliability {
  id               String   @id @default(uuid())
  userId           String   @unique
  reliabilityScore Float    @default(100.0)
  tier             String   @default("bronze") // bronze, silver, gold, platinum
  lastSessionAt    DateTime?
  lastDisconnectAt DateTime?
  lastDisconnectReason String? // manual_exit, network_drop, etc.
  consecutiveDrops Int      @default(0)
  totalSessions    Int      @default(0)
  successfulSessions Int    @default(0)
  completedSessions Int     @default(0)
  earlyExits       Int      @default(0)
  noShows          Int      @default(0)
  reportsReceived  Int      @default(0)
  consecutiveCompletions Int @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserPoints {
  id        String   @id @default(uuid())
  userId    String   @unique
  total     Int      @default(0)
  level     Int      @default(1)
  history   PointHistory[]
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PointHistory {
  id        String   @id @default(uuid())
  userPointsId String
  amount    Int
  reason    String
  createdAt DateTime @default(now())

  userPoints UserPoints @relation(fields: [userPointsId], references: [id], onDelete: Cascade)
}

model MatchmakingQueue {
  id        String   @id @default(uuid())
  userId    String
  structure String // 'free_talk', 'ielts_speaking', etc.
  status    String   @default("waiting") // waiting, matched, timeout
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status, structure])
}

model Friendship {
  id        String   @id @default(uuid())
  requesterId String
  addresseeId String
  status    String   @default("PENDING") // PENDING, ACCEPTED, REJECTED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  requester User @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  addressee User @relation("FriendshipAddressee", fields: [addresseeId], references: [id], onDelete: Cascade)

  @@unique([requesterId, addresseeId])
  @@index([requesterId])
  @@index([addresseeId])
}

model FriendRequest {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  status     String   @default("PENDING")
  createdAt  DateTime @default(now())

  sender     User @relation("FriendRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User @relation("FriendRequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([receiverId])
}

model ChatMessage {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String
  content    String
  read       Boolean  @default(false)
  createdAt  DateTime @default(now())

  sender     User @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([receiverId])
  @@index([read])
}

model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique
  bio         String?
  avatarUrl   String?
  streak      Int      @default(0)
  totalSessions Int    @default(0)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ConversationSession {
  id          String    @id @default(uuid())
  topic       String?
  structure   String?   // 'free_talk', 'ielts_speaking', etc.
  objectives  Json?     // Structured objectives for the session
  checkpoints Json?     // Progress checkpoints
  status      String    @default("CREATED") // CREATED, IN_PROGRESS, ENDED, PROCESSING, COMPLETED, ANALYSIS_FAILED
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  duration    Int?      // in seconds
  interactionMetrics Json? // interaction-specific scores (turn-taking, active listening)
  peerComparison      Json? // comparative analysis between participants
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  participants SessionParticipant[]
  analyses     Analysis[]
  tasks        LearningTask[]
  feedback     Feedback?
  reviews      PartnerReview[]
}

model SessionParticipant {
  id           String    @id @default(uuid())
  sessionId    String
  userId       String
  audioUrl     String?
  speakingTime Int       @default(0)
  turnsTaken   Int       @default(0)
  lastHeartbeat DateTime @default(now())

  session      ConversationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  analysis     Analysis?

  @@unique([sessionId, userId])
}

model Analysis {
  id            String   @id @default(uuid())
  sessionId     String
  participantId String   @unique // Refers to SessionParticipant.id
  rawData       Json     // Stores full FastAPI response
  cefrLevel     String?
  scores        Json     // { grammar, pronunciation, fluency, vocabulary, overall }
  confidenceTimeline Json? // timeline of confidence scores
  hesitationMarkers  Json? // filler words, self-corrections, false starts
  topicVocabulary    Json? // domain-specific vocabulary audit
  createdAt     DateTime @default(now())

  session      ConversationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participant  SessionParticipant  @relation(fields: [participantId], references: [id], onDelete: Cascade)
  mistakes     Mistake[]
  pronunciationIssues PronunciationIssue[]

  @@unique([sessionId, participantId])
  @@index([sessionId])
}

model Mistake {
  id                String   @id @default(uuid())
  analysisId        String
  type              String   // verb_form, article, etc.
  severity          String   @default("medium")
  segmentId         String
  original          String
  corrected         String
  rule              String?
  explanation       String
  cefrLevel         String?
  timestamp         Float
  reviewed          Boolean  @default(false)
  masteryScore      Float?
  createdAt         DateTime @default(now())

  analysis     Analysis      @relation(fields: [analysisId], references: [id], onDelete: Cascade)
  tasks        TaskMistake[]

  @@index([analysisId])
}

model PronunciationIssue {
  id          String   @id @default(uuid())
  analysisId  String
  word        String
  segmentId   String?
  phoneticExpected String?
  phoneticActual   String?
  issueType   String?
  severity    String   @default("medium")
  suggestion  String?
  audioStart  Float?
  audioEnd    Float?
  confidence  Float?
  createdAt   DateTime @default(now())

  analysis    Analysis @relation(fields: [analysisId], references: [id], onDelete: Cascade)

  @@index([analysisId])
}

model LearningTask {
  id               String    @id @default(uuid())
  userId           String
  sessionId        String?
  type             String    // grammar_drill, flashcard, etc.
  title            String
  content          Json
  status           String    @default("pending") // pending, completed
  estimatedMinutes Int       @default(5)
  dueDate          DateTime
  completedAt      DateTime?
  score            Float?
  createdAt        DateTime  @default(now())

  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  session          ConversationSession? @relation(fields: [sessionId], references: [id])
  mistakes         TaskMistake[]

  @@index([userId])
  @@index([status])
}

model TaskMistake {
  taskId    String
  mistakeId String

  task      LearningTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  mistake   Mistake      @relation(fields: [mistakeId], references: [id], onDelete: Cascade)

  @@id([taskId, mistakeId])
}

model Feedback {
  id          String    @id @default(uuid())
  sessionId   String    @unique
  transcript  String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  session     ConversationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}

model PartnerReview {
  id          String   @id @default(uuid())
  sessionId   String
  reviewerId  String
  revieweeId  String
  rating      Int      // 1-5
  comment     String?
  createdAt   DateTime @default(now())

  session     ConversationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  reviewer    User                @relation("ReviewsGiven", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewee    User                @relation("ReviewsReceived", fields: [revieweeId], references: [id], onDelete: Cascade)

  @@unique([sessionId, reviewerId])
  @@index([revieweeId])
}

model BlockedUser {
  id            String   @id @default(uuid())
  blockerId     String
  blockedUserId String
  createdAt     DateTime @default(now())

  blocker     User @relation("BlockingUser", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedUser User @relation("BlockedUser", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedUserId])
  @@index([blockedUserId])
}

model AssessmentSession {
  id               String           @id @default(uuid())
  userId           String
  status           AssessmentStatus @default(IN_PROGRESS)

  overallLevel     String?
  overallScore     Float?
  confidence       Float?
  talkStyle        TalkStyle?

  skillBreakdown   Json?
  weaknessMap      Json?
  improvementDelta Json?
  personalizedPlan Json?

  phase1Data       Json?
  phase2Data       Json?
  phase3Data       Json?
  phase4Data       Json?

  createdAt        DateTime @default(now())
  completedAt      DateTime?

  user             User     @relation(fields: [userId], references: [id])

  @@index([userId, status])
}

// ── Chat System (conversation-based) ─────────────────────────

model Conversation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants ConversationParticipant[]
  messages     Message[]
}

model ConversationParticipant {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime @default(now())
  lastReadAt     DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  senderId       String
  content        String
  type           String   @default("text") // text | call_invite | system
  metadata       Json?
  readBy         String[] @default([])
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("ChatMessagesSent", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
}

enum TalkStyle {
  DRIVER
  PASSENGER
}

enum AssessmentStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  ABANDONED
}

model UserTopicScore {
  id          String   @id @default(uuid())
  userId      String
  topicTag    String
  score       Float    @default(50.0)
  source      String   @default("activity") // "activity" | "session" | "assessment"
  occurrences Int      @default(1)           // how many times this weakness was detected
  lastSeenAt  DateTime @default(now())        // when was this weakness last detected
  decayRate   Float    @default(0.95)         // for score decay over time (multiply per day)
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, topicTag])
  @@index([userId])
  @@index([userId, score])  // for efficient top-weaknesses query
}

// Track which reels a user has already watched (to avoid repeats in feed)
model UserReelHistory {
  id           String   @id @default(uuid())
  userId       String
  strapiReelId Int      // Strapi reel ID
  watchedAt    DateTime @default(now())
  completed    Boolean  @default(false) // watched >80%

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, strapiReelId])
  @@index([userId])
}
